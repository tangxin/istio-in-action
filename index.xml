<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kuberbuilder 从零开始</title><link>https://books.tangx.in/istio-in-action/</link><description>Recent content on kuberbuilder 从零开始</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://books.tangx.in/istio-in-action/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://books.tangx.in/istio-in-action/01-install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/01-install/</guid><description>安装 docker-k3s-istio 开发环境 # 1. 安装 docker # 配置 docker 加速仓库
{ &amp;#34;registry-mirrors&amp;#34;: [ &amp;#34;https://mirror.ccs.tencentyun.com&amp;#34;, &amp;#34;https://wlzfs4t4.mirror.aliyuncs.com&amp;#34; ], &amp;#34;bip&amp;#34;: &amp;#34;169.253.32.1/24&amp;#34; } 上述是腾讯云和阿里云的加速仓库， 根据需求自行调整。
2. 安装 k3s # 2.1 安装 k3s # k3s 使用 --docker 模式是为了方便 docker build 产生的镜像可以直接用在 k3s 中。 否则在 k3s 和 docker 各自使用自己的 containerd runtime， 在程序发布的时候还需要再实现一个镜像 push 和 pull。 麻烦
仅用 --disable=traefik 其一是为了保证集群的干净， 只有一个 ingress 控制器。 其二是 traefik 和 istio 默认都使用 LB 控制器， 会抢占 80/443 端口。 直接禁用，懒得再卸载。</description></item><item><title/><link>https://books.tangx.in/istio-in-action/02-initial-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/02-initial-project/</guid><description>初始化第一个项目 # 项目代码在 https://github.com/tangx/istio-in-action 命令中有很多快捷键， 参考 install and prepare 1. 创建 namespace 并开启整体 istio 注入 # 1.1 创建 namespace myistio # kc ns myistio namespace/myistio created kns myistio Context &amp;#34;default&amp;#34; modified. Active namespace is &amp;#34;myistio&amp;#34;. 1.2 向 namespace 中开启 istio 注入 # # 向 ns 加入标签 istio-injection=enabled ， 开启注入 kubectl label namespace myistio istio-injection=enabled namespace/myistio labeleds # 查看具有 istio-injection 标签的 ns kgall ns -L istio-injection NAME STATUS AGE ISTIO-INJECTION kube-system Active 42d kube-public Active 42d istio-system Active 10m myistio Active 11s enabled default Active 42d 2.</description></item><item><title/><link>https://books.tangx.in/istio-in-action/03-vs-and-ingress/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/03-vs-and-ingress/</guid><description>isti VirtualService 和 k8s Ingress # 可以简单的认为 Ingress 是 k8s 中提出的流量入口转发的一个 标准定义规范（只是认为）。 怎么实现， 需要根据不同的 IngressController 的逻辑。
VirtualService 的部分功能就承担了 Ingress 的这一功能。
1. Ingress 与 VirtualService 的定义 # k8s Ingress 配置
apiVersion: networking.k8s.io/v1 kind: Ingress metadata: creationTimestamp: null name: simple spec: rules: - host: foo.com # 访问的域名 http: paths: - backend: service: name: svc1 # 后端服务名称 port: number: 80 path: /bar # 匹配的路由 pathType: Exact # 匹配模式 对应的 istio virtual service 配置如下</description></item><item><title/><link>https://books.tangx.in/istio-in-action/04-gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/04-gateway/</guid><description>使用 istio Gateway 允许外部访问 # 仅仅是简单的创建了 VirtualService 是不能实现集群外部的访问的。
在 Istio 中， 还有一个 Gateway 的概念。 顾名思义， Gateway 就是大门保安， 只允许具有特定特征的流量通过。
1.1. 创建 Gateway # 先来创建一个 Gateway
--- # https://istio.io/latest/docs/reference/config/networking/gateway/ apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: istio-tangx-in namespace: myistio spec: selector: istio: ingressgateway # 选择 ingressgateway, 省略则兼容所有 servers: - port: number: 80 name: http protocol: HTTP hosts: # - myistio/istio.tangx.in # 只针对特定的 namespace myistio 有效 - istio.tangx.in # 所有 ns 都有效 上述 gateway 注意以下几点。</description></item><item><title/><link>https://books.tangx.in/istio-in-action/05-vs-http-rewrite-by-uri/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/05-vs-http-rewrite-by-uri/</guid><description>VirtualService 使用路径重写 # 有了 VirtualService 的路径重写功能后， 就更符合 Ingress 的标准定义了。
但 VirtualService 不仅仅如此， 路径重写包含了三种方式
prefix: 前缀匹配。 只要 uri 路径的 前段 匹配则转发。 后端 自动补齐。 exact: 精确匹配。 只有 uri 全部 匹配才转发， 并且只能转发某一个固定地址。 精确匹配 regex: 正则匹配。 只有 uri 全部路径 满足正则规则 才转发。 正则规则: https://github.com/google/re2/wiki/Syntax 精确匹配， 正则模式也是精确匹配目标路径。 补充: 关于正则匹配模式官网资料也很少。
# https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPRewrite --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-prod - istio.</description></item><item><title/><link>https://books.tangx.in/istio-in-action/06-dr-subset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/06-dr-subset/</guid><description>使用 DestinationRule Subset 进行路由分组(版本控制) # 当一个程序并行发布多个版本的时候， 如 prod-v1 / prod-v2
kgd NAME READY UP-TO-DATE AVAILABLE AGE toolbox 1/1 1 1 3d22h prod-v1 1/1 1 1 16m prod-v2 1/1 1 1 16m // 两个版本的测试结果， 仅定义为 version 不一致 { &amp;quot;data&amp;quot;: { &amp;quot;Name&amp;quot;: &amp;quot;istio in action&amp;quot;, &amp;quot;Price&amp;quot;: 300, &amp;quot;Reviews&amp;quot;: null }, &amp;quot;version&amp;quot;: &amp;quot;v2.0.0&amp;quot; // &amp;quot;version&amp;quot;: &amp;quot;v1.0.0&amp;quot; } k8s Service 依旧实现最根本的 服务级别的 Selector。
--- # Service apiVersion: v1 kind: Service metadata: labels: app: prod name: svc-prod namespace: myistio spec: ports: - name: 80-8080 port: 80 protocol: TCP targetPort: 8080 selector: app: prod type: ClusterIP 默认情况下会根据 VirtualService 的默认规则 轮询 到后端的所有服务。</description></item><item><title/><link>https://books.tangx.in/istio-in-action/07-upgrade-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/07-upgrade-project/</guid><description>升级项目 # 之前的项目中只有 prod 服务，具有版本的区分。 现在对项目进行一些升级， 模拟一个多服务的项目。
两个服务， review / prod 服务之前还有调用关系。 prod -&amp;gt; review review # 这次新加入了 review 评论服务。
{ &amp;quot;1&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;zhangsan&amp;quot;, &amp;quot;commment&amp;quot;: &amp;quot;istio 功能很强大， 就是配置太麻烦&amp;quot; }, &amp;quot;2&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;wangwu&amp;quot;, &amp;quot;commment&amp;quot;: &amp;quot;《istio in action》 真是一本了不起的书&amp;quot; } } prod # 升级 prod 服务， 除了之前返回本身的数据信息之外，还需要返回关联的评论信息。
type Product struct { Name string Price int Reviews interface{} // 评论信息 } 这部分评论信息的来源就是上面新添加的评论服务。</description></item><item><title/><link>https://books.tangx.in/istio-in-action/08-vs-http-rewrite-by-header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/08-vs-http-rewrite-by-header/</guid><description>VirtualService 使用 header 重写路由 # 在 istio 中， 除了 path 之外还可以使用 Header 进行路由规则管理。
为了更好的展示 header 路由效果， 这里配合使用了 uri 的精确匹配模式。 实现之后， 只能访问地址 http://istio.tangx.in/ ， 其他均为 404。 具体哪个服务应答， 完全根据 header 匹配选择。
效果如下:
使用 Header 匹配有几个必要条件
Header 的 key 只能包含 小写字母 和 连字符 -。 从实际测试中来看。 这个规则只是一个 建议。 使用 驼峰(SrvReview) 时依旧可以转发。 Header 的 value 大小写敏感。 如果 Header 的值为 空， 则只检测 key 是否存在。 将 key 的匹配 值 设置为 空。 prefix, exact, regex 模式均可。 https://istio.</description></item><item><title/><link>https://books.tangx.in/istio-in-action/10-vs-http-redirect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/10-vs-http-redirect/</guid><description>VirtualService 路由重定向 # 在 VirtualService 配置中， 除了 http rewrite 路由重写之外， 还有 http redirect 路由重定向。 即常说的 30x。
https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPRedirect
http redirect # VirtualService 重定向配置如下。 有三个重要参数
uri: 重定向后的 uri redirectCode: 重定向时的 http response code。 ex: 301, 302。 默认值为 301 。 authority: 重定向后的 http host。 即 http response header 中的 location 字段。 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-http-redirect namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-review - istio.</description></item><item><title/><link>https://books.tangx.in/istio-in-action/11-vs-http-retry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/11-vs-http-retry/</guid><description>VirtualService 重试机制 # 在 Istio VirtualService 中， 有一个很关键的机制： 重试。
发起重试不需要业务本身实现， 而是 istio 通过 envoy 发起的。
其中有几个关键参数
attempts: 重试次数（不含初始请求）， 即最大请求次数为 n+1。
perTryTimeout: 发起重试的间隔时间。
必须大于 1ms。 默认于 http route 中的 timeout 一致， 即无 timeout 时间 retryOn: 执行重试的触发条件。
条件值有 envoy 提供: https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on http retry # --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-http-redirect namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-review - istio.</description></item><item><title/><link>https://books.tangx.in/istio-in-action/12-vs-http-fault-injection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/12-vs-http-fault-injection/</guid><description>VirtualService 混沌测试/错误注入 # 在 Istio 中还实现了一个很重要的功能: 错误注入。 可以设置 一定几率 出现 延迟(delay) 和 中止(abort) 错误。
Http Fault Injection Delay 延迟 # 一定概率出现 缓慢 相应。
fixedDelay: 延迟时间。 格式 1h / 1m / 1s。 最小 1ms。 percentage: 错误触发几率。 0-100 之间。 可以为 double 类型的小数。 --- # fault injection apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-fault-injection spec: hosts: - svc-review http: - match: route: - destination: host: svc-review fault: delay: percentage: value: 50 fixedDelay: 5s Http Fault Injection Abort 中止 # 一定概率出现 中止 相应， 并返回错误响应 http code</description></item><item><title/><link>https://books.tangx.in/istio-in-action/14-vs-http-header-operation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/14-vs-http-header-operation/</guid><description>VirtualService Header 操作 # 当 Envoy 在进行请求流量转发的时候， 还可以对消息 (request/response) 的 Header 进行操作。
set : 如果不存在， 则 创建 header， 如果存在， 则 覆盖 header spec: http: - headers: request: set: key1: value1 key2: value2 add : 如果不存在， 则 新增； 如果村子啊， 则 追加 spec: http: - headers: request: add: key1: value1 key2: value2 remove: 如果存在， 则 删除 header; 不存在, 则 忽略 spec: http: - headers: request: remove: - key1 - key2 测试用例 # 创建 vs-review 配置如下， 对 header reqeust 更新/追加/删除 进行操作。</description></item><item><title/><link>https://books.tangx.in/istio-in-action/16-lego-create-server-certificate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/16-lego-create-server-certificate/</guid><description>使用 lego 创建 https 证书 # https://go-acme.github.io/lego/dns/
#!/bin/bash # cd $(dirname $0) source .env lego --email=&amp;#34;${EMAIL}&amp;#34; \ --key-type rsa2048 \ --domains=&amp;#34;${DOMAIN1}&amp;#34; \ --path=$(pwd) --dns $DNS_PROVIDER --accept-tos run</description></item><item><title/><link>https://books.tangx.in/istio-in-action/17-gw-https-support-standard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/17-gw-https-support-standard/</guid><description>Gateway 支持 https 访问 - 标准模式 # https://istio.io/latest/docs/reference/config/networking/gateway/#ServerTLSSettings
credentialName: The secret (of type generic) should contain the following keys and values: key: &amp;lt;privateKey&amp;gt; and cert: &amp;lt;serverCert&amp;gt;
创建证书 k8s secret # 在 标准模式 下， 必须使用 key 作为私钥文件名， cert 作为证书文件名。 证书文件需要 保持 与 istio-ingressgateway 服务在 相同 的命名空间。 因此证书文件的创建命令如下
kubectl create secret generic wild-tangx-in \ --from-file=key=./certificates/_.tangx.in.key \ --from-file=cert=./certificates/_.tangx.in.crt \ -n istio-system 其中</description></item><item><title/><link>https://books.tangx.in/istio-in-action/18-dr-simple-loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/18-dr-simple-loadbalance/</guid><description>使用 DestionationRule 流量控制策略 - 简单负载均衡 # 简单负载均衡 策略， 官方指定名称。
ROUND_ROBIN: 轮训策略， 默认。 LEAST_CONN: 最小连接数。 随机 选择 两个健康 后端， 通过 O(1) 算法选择连接数最少的后端。 RANDOM: 随机选择了一个 健康 后端。 如果 没有配置健康检查策略， 随机策略比轮训更好。 PASSTHROUGH: 此选项会将连接转发到调用者请求的原始 IP 地址，而不进行任何形式的负载平衡。必须谨慎使用此选项。它适用于高级用例。有关更多详细信息，请参阅 Envoy 中的原始目标负载均衡器。 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-prod - istio.tangx.in http: - name: &amp;#34;v1-subset&amp;#34; route: - destination: host: svc-prod --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: dr-prod spec: host: svc-prod trafficPolicy: loadBalancer: # simple: RANDOM simple: ROUND_ROBIN # simple: PASSTHROUGH # simple: LEAST_CONN 部署测试 # ka -f istio-samples/18-dr-simple-loadbalance 10000 次请求， 2个后端， 差别不是很大</description></item><item><title/><link>https://books.tangx.in/istio-in-action/summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://books.tangx.in/istio-in-action/summary/</guid><description>目录 # 环境准备 # 安装 docker, k3s, istio 环境 初始化第一个项目 - prod 升级项目 - prod and review 使用 lego 创建 https 证书 VirtualService # istio VirtualService 和 k8s Ingress 创建 Gateway 允许外部访问 VirtualService 给予 uri 重写路由 使用 DestinationRule Subset 进行路由分组(版本控制) VirtualService 基于 Header 重写路由 VirtualService 支持重写路由的所有方式 VirtualService 路由重定向 VirtualService 的重试机制 VirtualService 注入错误实现混沌测试 VirtualService 委托: 测试失败 VirtualService Header 管理 VirutalService 根据客户端 Label 转发路由(sourceLabels): 待测试 Gateway 支持 https 访问 - 标准模式 使用 DestionationRule 流量控制策略 - 简单负载均衡</description></item></channel></rss>