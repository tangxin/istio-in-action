[{"id":0,"href":"/istio-in-action/01-install/","title":"01 Install","section":"","content":"安装 docker-k3s-istio 开发环境 #  1. 安装 docker #  配置 docker 加速仓库\n{ \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://mirror.ccs.tencentyun.com\u0026#34;, \u0026#34;https://wlzfs4t4.mirror.aliyuncs.com\u0026#34; ], \u0026#34;bip\u0026#34;: \u0026#34;169.253.32.1/24\u0026#34; } 上述是腾讯云和阿里云的加速仓库， 根据需求自行调整。\n2. 安装 k3s #  2.1 安装 k3s #    k3s 使用 --docker 模式是为了方便 docker build 产生的镜像可以直接用在 k3s 中。 否则在 k3s 和 docker 各自使用自己的 containerd runtime， 在程序发布的时候还需要再实现一个镜像 push 和 pull。 麻烦\n  仅用 --disable=traefik 其一是为了保证集群的干净， 只有一个 ingress 控制器。 其二是 traefik 和 istio 默认都使用 LB 控制器， 会抢占 80/443 端口。 直接禁用，懒得再卸载。\n  curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn INSTALL_K3S_EXEC=\u0026#34;server --docker --disable=traefik\u0026#34; sh - 如果之前已经安装过 k3s 的， 直接更在 systemd 启动文件后\n# /etc/systemd/system/k3s.service ExecStart=/usr/local/bin/k3s \\  server \\ \t\u0026#39;--docker\u0026#39; \\ \t\u0026#39;--disable=traefik\u0026#39; \\ 使用如果下命令重载配置并重启 k3s\nsystemctl daemon-reload systemctl restart k3s 2.2 复制 k3s config 文件 #  方便 kubectl 和之后的 istioctl 调用\nmkdir -p ~/.kube cp -a /etc/rancher/k3s/k3s.yaml ~/.kube/config 3. 安装 istio #  3.1 安装 istioctl #  export ISTIO_VERSION=1.11.4 mkdir -p /data/istio-install \u0026amp;\u0026amp; cd $_ wget -c https://github.com/istio/istio/releases/download/${ISTIO_VERSION}/istio-${ISTIO_VERSION}-linux-amd64.tar.gz \u0026amp;\u0026amp; tar xf istio-${ISTIO_VERSION}-linux-amd64.tar.gz \u0026amp;\u0026amp; mv istio-${ISTIO_VERSION} /usr/local/istio export PATH=/usr/local/istio/bin/:$PATH 3.2 安装 istio 控制器 #  这里安装预设的 demo 文件\nistioctl install --set profile=demo -y ✔ Istio core installed ✔ Istiod installed ✔ Egress gateways installed ✔ Ingress gateways installed ✔ Installation complete Thank you for installing Istio 1.11. Please take a few minutes to tell us about your install/upgrade experience! https://forms.gle/kWULBRjUv7hHci7T6 3.3 安装 kiali 和 prometheus #  kiali 是 istio 的一个可视化 dashboard， 必须配合 prometheus 一起使用才能达到最佳效果。\n幸运的是 istio 已经为我们准备好了所有东西。\n# 之前已经将 istio 安装包移动到了 /usr/local/istio export ISTIO_HOME=/usr/local/istio ka -f ${ISTIO_HOME}/samples/addons/kiali.yaml ka -f ${ISTIO_HOME}/samples/addons/prometheus.yaml 4. 安装快捷键 #  curl https://raw.githubusercontent.com/ahmetb/kubectx/master/kubens -o /usr/local/bin/kubens \u0026amp;\u0026amp; chmod +x /usr/local/bin/kubens 方便使用命令行查看。\nalias k=kubectl alias ka=\u0026#39;k apply\u0026#39; alias kaf=\u0026#39;kubectl apply -f\u0026#39; alias kc=\u0026#39;k create\u0026#39; alias kca=\u0026#39;_kca(){ kubectl \u0026#34;$@\u0026#34; --all-namespaces; unset -f _kca; }; _kca\u0026#39; alias kccc=\u0026#39;kubectl config current-context\u0026#39; alias kcdc=\u0026#39;kubectl config delete-context\u0026#39; alias kcgc=\u0026#39;kubectl config get-contexts\u0026#39; alias kcn=\u0026#39;kubectl config set-context --current --namespace\u0026#39; alias kcp=\u0026#39;kubectl cp\u0026#39; alias kcsc=\u0026#39;kubectl config set-context\u0026#39; alias kctx=kubectx alias kcuc=\u0026#39;kubectl config use-context\u0026#39; alias kd=\u0026#39;k describe\u0026#39; alias kdcj=\u0026#39;kubectl describe cronjob\u0026#39; alias kdcm=\u0026#39;kubectl describe configmap\u0026#39; alias kdd=\u0026#39;kubectl describe deployment\u0026#39; alias kdds=\u0026#39;kubectl describe daemonset\u0026#39; alias kdel=\u0026#39;kubectl delete\u0026#39; alias kdelcj=\u0026#39;kubectl delete cronjob\u0026#39; alias kdelcm=\u0026#39;kubectl delete configmap\u0026#39; alias kdeld=\u0026#39;kubectl delete deployment\u0026#39; alias kdelds=\u0026#39;kubectl delete daemonset\u0026#39; alias kdelf=\u0026#39;kubectl delete -f\u0026#39; alias kdeli=\u0026#39;kubectl delete ingress\u0026#39; alias kdelno=\u0026#39;kubectl delete node\u0026#39; alias kdelns=\u0026#39;kubectl delete namespace\u0026#39; alias kdelp=\u0026#39;kubectl delete pods\u0026#39; alias kdelpvc=\u0026#39;kubectl delete pvc\u0026#39; alias kdels=\u0026#39;kubectl delete svc\u0026#39; alias kdelsa=\u0026#39;kubectl delete sa\u0026#39; alias kdelsec=\u0026#39;kubectl delete secret\u0026#39; alias kdelss=\u0026#39;kubectl delete statefulset\u0026#39; alias kdi=\u0026#39;kubectl describe ingress\u0026#39; alias kdno=\u0026#39;kubectl describe node\u0026#39; alias kdns=\u0026#39;kubectl describe namespace\u0026#39; alias kdp=\u0026#39;kubectl describe pods\u0026#39; alias kdpvc=\u0026#39;kubectl describe pvc\u0026#39; alias kds=\u0026#39;kubectl describe svc\u0026#39; alias kdsa=\u0026#39;kubectl describe sa\u0026#39; alias kdsec=\u0026#39;kubectl describe secret\u0026#39; alias kdss=\u0026#39;kubectl describe statefulset\u0026#39; alias kecj=\u0026#39;kubectl edit cronjob\u0026#39; alias kecm=\u0026#39;kubectl edit configmap\u0026#39; alias ked=\u0026#39;kubectl edit deployment\u0026#39; alias keds=\u0026#39;kubectl edit daemonset\u0026#39; alias kei=\u0026#39;kubectl edit ingress\u0026#39; alias keno=\u0026#39;kubectl edit node\u0026#39; alias kens=\u0026#39;kubectl edit namespace\u0026#39; alias kep=\u0026#39;kubectl edit pods\u0026#39; alias kepvc=\u0026#39;kubectl edit pvc\u0026#39; alias kes=\u0026#39;kubectl edit svc\u0026#39; alias kess=\u0026#39;kubectl edit statefulset\u0026#39; alias keti=\u0026#39;kubectl exec -ti\u0026#39; alias kg=\u0026#39;k get\u0026#39; alias kga=\u0026#39;kubectl get all\u0026#39; alias kgaa=\u0026#39;kubectl get all --all-namespaces\u0026#39; alias kgall=\u0026#39;kg --all-namespaces\u0026#39; alias kgcj=\u0026#39;kubectl get cronjob\u0026#39; alias kgcm=\u0026#39;kubectl get configmaps\u0026#39; alias kgcma=\u0026#39;kubectl get configmaps --all-namespaces\u0026#39; alias kgd=\u0026#39;kubectl get deployment\u0026#39; alias kgda=\u0026#39;kubectl get deployment --all-namespaces\u0026#39; alias kgds=\u0026#39;kubectl get daemonset\u0026#39; alias kgdsw=\u0026#39;kgds --watch\u0026#39; alias kgdw=\u0026#39;kgd --watch\u0026#39; alias kgdwide=\u0026#39;kgd -o wide\u0026#39; alias kgi=\u0026#39;kubectl get ingress\u0026#39; alias kgia=\u0026#39;kubectl get ingress --all-namespaces\u0026#39; alias kgno=\u0026#39;kubectl get nodes\u0026#39; alias kgns=\u0026#39;kubectl get namespaces\u0026#39; alias kgp=\u0026#39;kubectl get pods\u0026#39; alias kgpa=\u0026#39;kubectl get pods --all-namespaces\u0026#39; alias kgpall=\u0026#39;kubectl get pods --all-namespaces -o wide\u0026#39; alias kgpl=\u0026#39;kgp -l\u0026#39; alias kgpn=\u0026#39;kgp -n\u0026#39; alias kgpvc=\u0026#39;kubectl get pvc\u0026#39; alias kgpvca=\u0026#39;kubectl get pvc --all-namespaces\u0026#39; alias kgpvcw=\u0026#39;kgpvc --watch\u0026#39; alias kgpw=\u0026#39;kgp -o wide\u0026#39; alias kgpwide=\u0026#39;kgp -o wide\u0026#39; alias kgpy=\u0026#39;kgp -o yaml\u0026#39; alias kgrs=\u0026#39;kubectl get rs\u0026#39; alias kgs=\u0026#39;kubectl get svc\u0026#39; alias kgsa=\u0026#39;kubectl get svc --all-namespaces\u0026#39; alias kgsec=\u0026#39;kubectl get secret\u0026#39; alias kgseca=\u0026#39;kubectl get secret --all-namespaces\u0026#39; alias kgss=\u0026#39;kubectl get statefulset\u0026#39; alias kgssa=\u0026#39;kubectl get statefulset --all-namespaces\u0026#39; alias kgssw=\u0026#39;kgss --watch\u0026#39; alias kgsswide=\u0026#39;kgss -o wide\u0026#39; alias kgsw=\u0026#39;kgs --watch\u0026#39; alias kgswide=\u0026#39;kgs -o wide\u0026#39; alias khelp=\u0026#39;cat /Users/tangxin/.zshrc.d/k8s.profile\u0026#39; alias kk=\u0026#39;k kustomize\u0026#39; alias kl=\u0026#39;kubectl logs\u0026#39; alias kl1h=\u0026#39;kubectl logs --since 1h\u0026#39; alias kl1m=\u0026#39;kubectl logs --since 1m\u0026#39; alias kl1s=\u0026#39;kubectl logs --since 1s\u0026#39; alias klf=\u0026#39;kubectl logs -f\u0026#39; alias klf1h=\u0026#39;kubectl logs --since 1h -f\u0026#39; alias klf1m=\u0026#39;kubectl logs --since 1m -f\u0026#39; alias klf1s=\u0026#39;kubectl logs --since 1s -f\u0026#39; alias kns=kubens alias kpf=\u0026#39;kubectl port-forward\u0026#39; alias krh=\u0026#39;kubectl rollout history\u0026#39; alias krm=\u0026#39;k delete\u0026#39; alias krsd=\u0026#39;kubectl rollout status deployment\u0026#39; alias krsss=\u0026#39;kubectl rollout status statefulset\u0026#39; alias kru=\u0026#39;kubectl rollout undo\u0026#39; alias ksd=\u0026#39;kubectl scale deployment\u0026#39; alias ksss=\u0026#39;kubectl scale statefulset\u0026#39; "},{"id":1,"href":"/istio-in-action/02-initial-project/","title":"02 Initial Project","section":"","content":"初始化第一个项目 #   项目代码在 https://github.com/tangx/istio-in-action 命令中有很多快捷键， 参考 install and prepare  1. 创建 namespace 并开启整体 istio 注入 #  1.1 创建 namespace myistio #  kc ns myistio namespace/myistio created kns myistio Context \u0026#34;default\u0026#34; modified. Active namespace is \u0026#34;myistio\u0026#34;. 1.2 向 namespace 中开启 istio 注入 #  # 向 ns 加入标签 istio-injection=enabled ， 开启注入 kubectl label namespace myistio istio-injection=enabled namespace/myistio labeleds # 查看具有 istio-injection 标签的 ns kgall ns -L istio-injection NAME STATUS AGE ISTIO-INJECTION kube-system Active 42d kube-public Active 42d istio-system Active 10m myistio Active 11s enabled default Active 42d 2. 创建第一个项目 #  . ├── cmd │ └── prod // 项目名称 ├── dockerfiles // 编译镜像使用的 dockerfile ├── scripts │ └── deployment // k8s 发布时用的 yaml 文件。 通过渲染发布 ├── .version // 版本编号管理 └── version // go 程序版本注入 2.1 程序说明 #  程序功能很简单， 就是在请求地址 http://servername/prod/list 是返回一个固定结果, 如下。\n{ \u0026#34;data\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;istio in action\u0026#34;, \u0026#34;Price\u0026#34;: 300, \u0026#34;Reviews\u0026#34;: null }, \u0026#34;version\u0026#34;: \u0026#34;v1.0.0\u0026#34; }  data 的值是在 gin handler 中固定写死的。 /cmd/prod/main.go version 是通过 /version/version.go 在编译时注入的， 其值来源于文件 .version。  使用如下命令进行编译发布\nmake apply.docker 3. 简单测试 #  在 myistio namespace 下创建一个容器， 作为客户端。\nksn myistio k create deployment toolbox --image=nginx:alpine 进入创建的工具容器， 使用 curl 调用 prod 服务。 确认调用无异常。\nketi toolbox-77889d56fd-dnfbz sh kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead. curl svc-prod/prods/list {\u0026#34;data\u0026#34;:{\u0026#34;Name\u0026#34;:\u0026#34;istio in action\u0026#34;,\u0026#34;Price\u0026#34;:300,\u0026#34;Reviews\u0026#34;:null},\u0026#34;version\u0026#34;:\u0026#34;v1.0.0\u0026#34;} "},{"id":2,"href":"/istio-in-action/03-vs-and-ingress/","title":"03 vs and Ingress","section":"","content":"isti VirtualService 和 k8s Ingress #  可以简单的认为 Ingress 是 k8s 中提出的流量入口转发的一个 标准定义规范（只是认为）。 怎么实现， 需要根据不同的 IngressController 的逻辑。\nVirtualService 的部分功能就承担了 Ingress 的这一功能。\n1. Ingress 与 VirtualService 的定义 #  k8s Ingress 配置\napiVersion: networking.k8s.io/v1 kind: Ingress metadata: creationTimestamp: null name: simple spec: rules: - host: foo.com  # 访问的域名 http: paths: - backend: service: name: svc1  # 后端服务名称 port: number: 80 path: /bar  # 匹配的路由 pathType: Exact  # 匹配模式 对应的 istio virtual service 配置如下\napiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prods namespace: myistio spec: hosts: - svc-prod  # 访问地址 http: - route: - destination: host: svc-prod  # 后端服务名称 可以看到， VirtualService 的配置大致与 Ingress 相似。 这里 VS 中没有指定 path 规则， 将在以后路由转发中提到。\n https://istio.io/latest/zh/docs/concepts/traffic-management/#the-hosts-field\n 虚拟服务主机名可以是 IP 地址、DNS 名称，或者依赖于平台的一个简称（例如 Kubernetes 服务的短名称）， 隐式或显式地指向一个完全限定域名（FQDN） 。您也可以使用通配符（“*”）前缀，让您创建一组匹配所有服务的路由规则。虚拟服务的 hosts 字段实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址。这让您可以为没有路由到网格内部的虚拟主机建模。\n 隐式或显式地指向一个完全限定域名（FQDN）: 即， 客户端 需要能解析该域名。 因此在内网时通常需要使用 service name， k8s coredns 完成了域名解析。 在使用非集群地址时 （ex. 公网域名时） 可以通过 dns 解析， 也可以是修改 /etc/hosts 文件。\n 2. 测试 VirtualService #  使用如如下命令, 创建 VirtualService\nkubectl apply -f istio-samples/03/ 部署完成后， 进入到 toolbox 请求 svc-prod\ncurl svc-prod/prod/list {\u0026#34;data\u0026#34;:{\u0026#34;Name\u0026#34;:\u0026#34;istio in action\u0026#34;,\u0026#34;Price\u0026#34;:300,\u0026#34;Reviews\u0026#34;:null},\u0026#34;version\u0026#34;:\u0026#34;v1.0.0\u0026#34;} 这个时候能请求， 但是结果看不出什么有什么特别s， 打开之前部署的 kiali\n进入到 Graph -\u0026gt; namespace (myistio) -\u0026gt; traffic -\u0026gt; service grpha 就可以看到流量请求了\n "},{"id":3,"href":"/istio-in-action/04-gateway/","title":"04 Gateway","section":"","content":"使用 istio Gateway 允许外部访问 #  仅仅是简单的创建了 VirtualService 是不能实现集群外部的访问的。\n在 Istio 中， 还有一个 Gateway 的概念。 顾名思义， Gateway 就是大门保安， 只允许具有特定特征的流量通过。\n1.1. 创建 Gateway #  先来创建一个 Gateway\n--- # https://istio.io/latest/docs/reference/config/networking/gateway/ apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: istio-tangx-in namespace: myistio spec: selector: istio: ingressgateway # 选择 ingressgateway, 省略则兼容所有 servers: - port: number: 80 name: http protocol: HTTP hosts: # - myistio/istio.tangx.in # 只针对特定的 namespace myistio 有效 - istio.tangx.in # 所有 ns 都有效 上述 gateway 注意以下几点。\n 使用 .spec.selector 选择了绑定的 ingressgateway。 如果 省略 则绑定到所有的 ingressgateway。  kgall deployment -l istio=ingressgateway NAMESPACE NAME READY UP-TO-DATE AVAILABLE AGE istio-system istio-ingressgateway 1/1 1 1 3d23h  .spec.servers.port 指定了 gateway 允许的 端口 和 协议。\n 截止 istio v1.11.4 只支持 HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS 7中。    .sepc.servers.hosts 指定了允许通过的 域名。\n 如果使用 ns_name/istio.tangx.in namespace 字段， 则表示只有 特定 的namespace 中生效。 istio.tangx.in 如果没有 ns 字段， 则表示所有 ns 中生效。    1.2. VirutalService 定义 #  随后， 更新 VirtualService 配置\n--- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod namespace: myistio spec: gateways: # 选择 gateway - istio-tangx-in  # 这里的名字要与 gateway 的名字匹配 hosts: - svc-prod - istio.tangx.in  # 使用的外部地址 FQDN。 这里的域名是 gateway hosts 中定义的 http: - route: - destination: host: svc-prod 需要注意\n .spec.gateways 的列表值必须是存在的 gateway 名称 .spec.hosts 的值， 必须是上述选中的 gateway 中定义的。  2. 测试 #  运行如下命令创建相关环境\nkubectl apply -f istio-samples/04/ 使用 04.http 的 GET 请求进行测试\n  注意: 使用访问的外部域名 istio.tangx.in 一定要进行 dns 解析。 或使用 /etc/resolv.conf 进行绑定。\n "},{"id":4,"href":"/istio-in-action/05-vs-http-rewrite-by-uri/","title":"05 vs HTTP Rewrite by URI","section":"","content":"VirtualService 使用路径重写 #  有了 VirtualService 的路径重写功能后， 就更符合 Ingress 的标准定义了。\n但 VirtualService 不仅仅如此， 路径重写包含了三种方式\n prefix: 前缀匹配。 只要 uri 路径的 前段 匹配则转发。 后端 自动补齐。 exact: 精确匹配。 只有 uri 全部 匹配才转发， 并且只能转发某一个固定地址。  精确匹配   regex: 正则匹配。 只有 uri 全部路径 满足正则规则 才转发。  正则规则: https://github.com/google/re2/wiki/Syntax 精确匹配， 正则模式也是精确匹配目标路径。     补充: 关于正则匹配模式官网资料也很少。\n # https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPRewrite --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-prod - istio.tangx.in http: - name: \u0026#34;prefix-match\u0026#34; # 规则名称 match: - uri: prefix: \u0026#34;/p1\u0026#34; # 新路径, prefix 前缀匹配， 满足 /p1 的都要被重写 rewrite: uri: \u0026#34;/prod\u0026#34; # 老路径 route: - destination: host: svc-prod  # 后端服务 - name: \u0026#34;exact-match\u0026#34; match: - uri: exact: \u0026#34;/p2-list\u0026#34; # 新路径， exact 精确匹配， 只能满足 /p2-list rewrite: uri: \u0026#34;/prod/list\u0026#34; # 精确匹配 route: - destination: host: svc-prod - name: \u0026#34;regex-match\u0026#34; match: - uri: regex: \u0026#34;/pr[1-3]/.*\u0026#34; # 新路径, regex 正则匹配。 正则匹配的整个 uri，因此允许所有要 使用 `.*`。 正则规则使用: https://github.com/google/re2/wiki/Syntax rewrite: uri: \u0026#34;/prod/list\u0026#34; ## 精确匹配路径 route: - destination: host: svc-prod  https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPRewrite\n 测试 #  执行命令， 部署环境。 （快捷键见第一章）\nka -f istio-samples/05 使用 05.http 中的测试用例， 进行测试。\n### GET，原访问地址 # 现在已经 404 GET http://istio.tangx.in/prod/list ### GET 使用路径重写: prefix 前缀匹配 GET http://istio.tangx.in/p1/list ### GET 使用路径重写: exact 精确匹配 GET http://istio.tangx.in/p2-list ### GET 使用路径重写: regex 正则匹配(有效) GET http://istio.tangx.in/pr3/list ### GET 使用路径重写: regex 正则匹配(无效) GET http://istio.tangx.in/pr4/list 不同的 404 not found #  客户端请求后得到的 404 not found 有两种\n istio 没有匹配到路由规则而返回的 404.  ### GET，原访问地址 # 现在已经 404, istio 返回 GET http://istio.tangx.in/prod/list # HTTP/1.1 404 Not Found # date: Mon, 15 Nov 2021 04:19:43 GMT # server: istio-envoy # connection: close # content-length: 0 istio 成功将请求转发到后端server， 后端 server 找不到路由而返回的 404。  ### GET 使用路径重写: prefix 前缀匹配 # 404 not found, server 返回。 GET http://istio.tangx.in/p1/list2 # HTTP/1.1 404 Not Found # content-type: text/plain # date: Mon, 15 Nov 2021 04:20:09 GMT # content-length: 18 # x-envoy-upstream-service-time: 0 # server: istio-envoy # connection: close # 404 page not found "},{"id":5,"href":"/istio-in-action/06-dr-subset/","title":"06 Dr Subset","section":"","content":"使用 DestinationRule Subset 进行路由分组(版本控制) #  当一个程序并行发布多个版本的时候， 如 prod-v1 / prod-v2\nkgd NAME READY UP-TO-DATE AVAILABLE AGE toolbox 1/1 1 1 3d22h prod-v1 1/1 1 1 16m prod-v2 1/1 1 1 16m // 两个版本的测试结果， 仅定义为 version 不一致 { \u0026quot;data\u0026quot;: { \u0026quot;Name\u0026quot;: \u0026quot;istio in action\u0026quot;, \u0026quot;Price\u0026quot;: 300, \u0026quot;Reviews\u0026quot;: null }, \u0026quot;version\u0026quot;: \u0026quot;v2.0.0\u0026quot; // \u0026quot;version\u0026quot;: \u0026quot;v1.0.0\u0026quot; } k8s Service 依旧实现最根本的 服务级别的 Selector。\n--- # Service apiVersion: v1 kind: Service metadata: labels: app: prod name: svc-prod namespace: myistio spec: ports: - name: 80-8080 port: 80 protocol: TCP targetPort: 8080 selector: app: prod type: ClusterIP 默认情况下会根据 VirtualService 的默认规则 轮询 到后端的所有服务。\n使用 subset 实现路由控制 #  但是在一些特定的环境下，需要对路由或者流量进行精确的认为控制。 这个时候就需要对后端服务进行 分组 处理。\n这个时候就可以使用 istio 的 subset 功能。 subset 的定义为 Service Version (服务版本)， 产生的目的就是为了在持续集成场景中， 可以通过 路由、 请求头(Header)、权重等 等方式进行路由或流量控制，以便进行 A/B 测试、金丝雀测试等。\nDestinationRule 服务分组 #  在 vs 使用 subset 的时候， 必须依赖 DestinationRule 控制器进行 后端服务的分组。\nDR 通过 label 规则对后端进行服务分组。\n这样当流量达到 envoy 的以后， 进一步根据 label-\u0026gt; version:v1 选择真是的后端服务。\napiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: dr-prod spec: host: svc-prod subsets: - name: subset-groupv1 labels: version: v1 - name: subset-groupv2 labels: version: v2 1. 使用 流量权重 实现分组 #  在 同一个 路由规则下， 可以使用 权重模式 ， 将流量分发到不同的后端 subset 组中。\n 注意: 权重值的总和必须是 100 。\n --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-prod - istio.tangx.in http: - name: \u0026#34;v1-subset\u0026#34; route: # 同一个 route 下面的两个 destination - destination: host: svc-prod subset: subset-groupv1  # subset 的值与 DestinationRule 中定义一致 weight: 25 - destination: host: svc-prod subset: subset-groupv2 weight: 75 使用如下命令进行测试\nka -f istio-samples/06-dr-subset/ ka -f istio-samples/06-dr-subset/vs/03-subset-weight.yml 2. 使用 路由重写 实现分组 #  路由重写 只是路由分组其中一个小的分支。 同样还可以使用 header， queryParams 参数。 逻辑都是类似的。\n在 VirtualService 配置中， 使用多个 route 规则， 将流量转发到不同的后端组。\n--- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-prod - istio.tangx.in http: - name: \u0026#34;v2-routes\u0026#34; # 路由重写分组， 是针对不同的路由匹配规则 match: - uri: prefix: \u0026#34;/v2/prod\u0026#34; # 新增一个路由匹配规则， 只有 uri 满足 /v2/prod 才会访问 v2 版本的 pod rewrite: uri: \u0026#34;/prod\u0026#34; route: - destination: host: svc-prod subset: subset-groupv2 - name: \u0026#34;default-routes\u0026#34; # 可以说是默认分组 route: - destination: host: svc-prod subset: subset-groupv1 使用如下命令进行测试\nka -f istio-samples/06/ ka -f istio-samples/06/vs/02-subset-rewrite-path.yml 流量的目的地址 #  这里总结一下， 无论是在 VirtualService 还是在 DestinationRule 中， 流量的目的地址都是 k8s service。\n 注意: 这里的 k8s service 指的是在 istio 以外能满足 FQDN\n --- # DestinationRule apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule spec: host: svc-prod  # 目的地址是 svc # .... --- # VirtualService apiVersion: networking.istio.io/v1alpha3 kind: VirtualService spec: http: - name: \u0026#34;default-routes\u0026#34; route: - destination: host: svc-prod  # 目的地址是 svc subset: subset-groupv1 # ..... "},{"id":6,"href":"/istio-in-action/07-upgrade-project/","title":"07 Upgrade Project","section":"","content":"升级项目 #  之前的项目中只有 prod 服务，具有版本的区分。 现在对项目进行一些升级， 模拟一个多服务的项目。\n 两个服务， review / prod 服务之前还有调用关系。 prod -\u0026gt; review  review #  这次新加入了 review 评论服务。\n{ \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;zhangsan\u0026quot;, \u0026quot;commment\u0026quot;: \u0026quot;istio 功能很强大， 就是配置太麻烦\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;wangwu\u0026quot;, \u0026quot;commment\u0026quot;: \u0026quot;《istio in action》 真是一本了不起的书\u0026quot; } } prod #  升级 prod 服务， 除了之前返回本身的数据信息之外，还需要返回关联的评论信息。\ntype Product struct { Name string Price int Reviews interface{} // 评论信息 } 这部分评论信息的来源就是上面新添加的评论服务。\nfunc getReivews() (map[string]model.Review, error) { reviews := make(map[string]model.Review) resp, err := http.Get(\u0026#34;http://svc-review/review/all\u0026#34;) if err != nil { return nil, fmt.Errorf(\u0026#34;reqeust svc-review failed: %v\u0026#34;, err) } defer resp.Body.Close() data, err := ioutil.ReadAll(resp.Body) if err != nil { return nil, fmt.Errorf(\u0026#34;read body failed: %v\u0026#34;, err) } err = json.Unmarshal(data, \u0026amp;reviews) if err != nil { return nil, fmt.Errorf(\u0026#34;json unmarshal data failed: %v\u0026#34;, err) } return reviews, nil } 完整结果如下\n{ \u0026quot;data\u0026quot;: { \u0026quot;Name\u0026quot;: \u0026quot;istio in action\u0026quot;, \u0026quot;Price\u0026quot;: 300, \u0026quot;Reviews\u0026quot;: { \u0026quot;1\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;zhangsan\u0026quot;, \u0026quot;commment\u0026quot;: \u0026quot;istio 功能很强大， 就是配置太麻烦\u0026quot; }, \u0026quot;2\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;wangwu\u0026quot;, \u0026quot;commment\u0026quot;: \u0026quot;《istio in action》 真是一本了不起的书\u0026quot; } } }, \u0026quot;version\u0026quot;: \u0026quot;v1.1.0\u0026quot; } "},{"id":7,"href":"/istio-in-action/08-vs-http-rewrite-by-header/","title":"08 vs HTTP Rewrite by Header","section":"","content":"VirtualService 使用 header 重写路由 #  在 istio 中， 除了 path 之外还可以使用 Header 进行路由规则管理。\n为了更好的展示 header 路由效果， 这里配合使用了 uri 的精确匹配模式。 实现之后， 只能访问地址 http://istio.tangx.in/ ， 其他均为 404。 具体哪个服务应答， 完全根据 header 匹配选择。\n效果如下:\n 使用 Header 匹配有几个必要条件\n Header 的 key 只能包含 小写字母 和 连字符 -。  从实际测试中来看。 这个规则只是一个 建议。 使用 驼峰(SrvReview) 时依旧可以转发。   Header 的 value 大小写敏感。 如果 Header 的值为 空， 则只检测 key 是否存在。  将 key 的匹配 值 设置为 空。 prefix, exact, regex 模式均可。     https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest\n 匹配模式 #  与之前的 路径匹配 相似， header 匹配也具有三种模式。\n prefix: 前缀模式 exact: 精确模式 regex: 正则模式  1. 前缀模式 #  header 的 key 相同， value 从零开始相同。 与正则规则 ^value.* 等价\n请求方式如下\n### GET prod: 前缀模式: 匹配 x-prod GET http://istio.tangx.in/ app: x-prod-anything VirtualService 配置如下\n--- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-header-route namespace: myistio spec: gateways: # 选择 gateway - istio-tangx-in hosts: - istio.tangx.in http: - name: \u0026#34;prod-route\u0026#34; match: - headers: app: prefix: x-prod  # 使用 前缀模式 uri: # 为了更好的展示 header 路由。 这里配合 uri 的精确匹配模式 exact: / rewrite: uri: /prod/list route: - destination: host: svc-prod 2. 精确模式 #  header 的 key,value 必须完全匹配规则。\n请求方式如下\n### GET reivew: 精确模式， app 的值必须是 review GET http://istio.tangx.in/ app: review VirtualService 规则如下\n--- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-header-route namespace: myistio spec: gateways: # 选择 gateway - istio-tangx-in hosts: - istio.tangx.in http: - name: \u0026#34;review-route\u0026#34; match: - headers: app: exact: review  # 使用精确模式 uri: exact: / rewrite: uri: /review/all route: - destination: host: svc-review 3. 正则模式 #  略\n只检测 key 不检测 value #  将任意匹配规则 prefix / exact / regex 的匹配值结果设置为 空。\n## 省略 # If the value is empty and only the name of header is specfied, presence of the header is checked. - name: \u0026#34;key without value\u0026#34; match: - headers: onlykey: prefix: \u0026#34;\u0026#34; # 有 key 没有 value # exact: \u0026#34;\u0026#34; # 有 key 没有 value # regex: \u0026#34;\u0026#34; # 有 key 没有 value uri: exact: / rewrite: uri: /review/all route: - destination: host: svc-review 一些违反规范规则的测试 #  # https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-header-route namespace: myistio spec: gateways: # 选择 gateway - istio-tangx-in hosts: - istio.tangx.in http: ## 一些违反规则的测试 ### # The keys uri, scheme, method, and authority will be ignored. # 其实不会被忽略 - name: \u0026#34;key (uri) in header\u0026#34; match: - headers: uri: exact: \u0026#34;app\u0026#34; uri: exact: / rewrite: uri: /review/all route: - destination: host: svc-review # The header keys must be lowercase and use hyphen as the separator, e.g. x-request-id. # 其实可以为大写 - name: \u0026#34;uppercase in keys\u0026#34; match: - headers: SrvReview: exact: \u0026#34;review\u0026#34; uri: exact: / rewrite: uri: /review/all route: - destination: host: svc-review 测试结果\n# 违反规则的测试 #### 1. header key 出现关键字将被忽略 # \u0026gt; 关键字出现， 不会被忽略 GET http://istio.tangx.in/ uri: app #### 2. header key 只能是 `小写字母` 和 `-` # \u0026gt; 可以为大写 GET http://istio.tangx.in/ SrvReview: review "},{"id":8,"href":"/istio-in-action/10-vs-http-redirect/","title":"10 vs HTTP Redirect","section":"","content":"VirtualService 路由重定向 #  在 VirtualService 配置中， 除了 http rewrite 路由重写之外， 还有 http redirect 路由重定向。 即常说的 30x。\n https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPRedirect\n http redirect #  VirtualService 重定向配置如下。 有三个重要参数\n uri: 重定向后的 uri redirectCode: 重定向时的 http response code。 ex: 301, 302。 默认值为 301 。 authority: 重定向后的 http host。 即 http response header 中的 location 字段。  --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-http-redirect namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-review - istio.tangx.in http: - match: - uri: exact: /review redirect: uri: /review/all redirectCode: 302 authority: svc-review  # 重定向后的地址。 使用 curl 命令请求测试， 结果如下。\ncurl -I http://istio.tangx.in/review HTTP/1.1 302 Found location: http://svc-review/review/all date: Mon, 15 Nov 2021 10:32:59 GMT server: istio-envoy transfer-encoding: chunked 可以看到已经正常实现重定向。\n兼顾内群内外的重定向 #  但是 location: http://svc-review/review/all 结果是集群内部地址， 而我们的请求时从集群外部发起的访问。\n虽然可以将 authority 字段的值修改为 集群外部地址。\nhttp: - match: - uri: exact: /review redirect: uri: /review/all redirectCode: 302 # authority: svc-review authority: istio.tangx.in 但这是一个 蠢到爆 的方式。\n 每次请求都必须要走 外部网关 外部地址与 VirtualService 强耦合， 无法适配多地址的情况。  相同路由规则下 redirect 和 route 互斥 #  下面这个规则是不合法的， 在 同一条 路由规则下， redirect 和 route 互斥。\n--- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-http-redirect namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-review - istio.tangx.in http: - match: - uri: exact: /review redirect: uri: /review/all redirectCode: 302 route: # redirect 和 route 在同一条规则下互斥 - destination: host: svc-review 报错如下\nfor: \u0026quot;istio-samples/10-http-redirect/vs.yml\u0026quot;: admission webhook \u0026quot;validation.istio.io\u0026quot; denied the request: configuration is invalid: HTTP route cannot contain both route and redirect 使用多路由规则无法兼顾鱼和熊掌 #   遗留问题: 虽然 redirect 和 route 不能在 同一个 规则下。 但是他们可以在 不同 规则下。 因此使用 多条 路由规则即可兼得鱼和熊掌 ???\n 经测试发现， 如下包含 gateway 字段的 VirtualService 定义， 无法完成内网的 http-redirect。\n--- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-http-redirect namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-review - istio.tangx.in http: # 规则重定向 - match: - uri: exact: /review redirect: uri: /review/all redirectCode: 302 # 路由转发 - match: - uri: prefix: / route: - destination: host: svc-review 在集群内部的 toolbox 容器中的执行命令， 出现 not found 错误。\ncurl -I http://svc-review/review HTTP/1.1 404 Not Found date: Mon, 15 Nov 2021 11:08:00 GMT server: istio-envoy transfer-encoding: chunked 使用多配置兼得鱼和熊掌（不优雅） #  没办法， 只能创建两个配置实现内外网的重定向\n 不包含 gateway 的 vs.yml 包含 gateway 的 vs-gateway.yml  "},{"id":9,"href":"/istio-in-action/11-vs-http-retry/","title":"11 vs HTTP Retry","section":"","content":"VirtualService 重试机制 #  在 Istio VirtualService 中， 有一个很关键的机制： 重试。\n发起重试不需要业务本身实现， 而是 istio 通过 envoy 发起的。\n其中有几个关键参数\n  attempts: 重试次数（不含初始请求）， 即最大请求次数为 n+1。\n  perTryTimeout: 发起重试的间隔时间。\n 必须大于 1ms。 默认于 http route 中的 timeout 一致， 即无 timeout 时间    retryOn: 执行重试的触发条件。\n 条件值有 envoy 提供: https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on    http retry #  --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-http-redirect namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-review - istio.tangx.in http: - match: - uri: prefix: / route: - destination: host: svc-review retries: # 重试 attempts: 3 # 重试次数（不含本身一次）， 共计 4 次。 perTryTimeout: 2s # 间隔时间， 默认 25ms。必须大于 1ms retryOn: gateway-error,connect-failure,refused-stream # 触发条件 测试 #  部署用例 11 进行测试。\nka -f istio-samples/11-http-retry 执行 curl 请求命令， 通过结果可以看到， 总共耗时 8 秒。\ntime curl http://istio.tangx.in/review/delay?delay=3 upstream request timeout real 0m8.118s user 0m0.000s sys 0m0.010s 通过 review 的日志可以看到， 总共请求了 4次 (1+3), 每次间隔 2秒 。 刚好 8 秒超时\n[GIN] 2021/11/15 - 15:56:08 | 200 | 3.000822016s | 10.42.0.1 | GET \u0026quot;/review/delay?delay=3\u0026quot; [GIN] 2021/11/15 - 15:56:10 | 200 | 3.000916703s | 10.42.0.1 | GET \u0026quot;/review/delay?delay=3\u0026quot; [GIN] 2021/11/15 - 15:56:12 | 200 | 3.000723194s | 10.42.0.1 | GET \u0026quot;/review/delay?delay=3\u0026quot; [GIN] 2021/11/15 - 15:56:14 | 200 | 3.000565097s | 10.42.0.1 | GET \u0026quot;/review/delay?delay=3\u0026quot; 设置 timeout #  如下, 增加 http route 的全局 timeout 参数。\n# ... 略 timeout: 5s # 总请求时间不会操作 timeout 时常 retries: # 重试 attempts: 3 perTryTimeout: 2s  retryOn: gateway-error,connect-failure,refused-stream  虽然按照 重试 逻辑依旧需要 4次 8秒。 但受限于 timeout 的阈值， 请求在 5秒 后超时退出。\ntime curl http://istio.tangx.in/review/delay?delay=3 upstream request timeout real 0m5.012s user 0m0.009s sys 0m0.000s "},{"id":10,"href":"/istio-in-action/12-vs-http-fault-injection/","title":"12 vs HTTP Fault Injection","section":"","content":"VirtualService 混沌测试/错误注入 #  在 Istio 中还实现了一个很重要的功能: 错误注入。 可以设置 一定几率 出现 延迟(delay) 和 中止(abort) 错误。\nHttp Fault Injection Delay 延迟 #  一定概率出现 缓慢 相应。\n fixedDelay: 延迟时间。 格式 1h / 1m / 1s。 最小 1ms。 percentage: 错误触发几率。 0-100 之间。 可以为 double 类型的小数。  --- # fault injection apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-fault-injection spec: hosts: - svc-review http: - match: route: - destination: host: svc-review fault: delay: percentage: value: 50 fixedDelay: 5s Http Fault Injection Abort 中止 #  一定概率出现 中止 相应， 并返回错误响应 http code\n httpStatus: 错误响应 http code。 percentage: 错误触发几率。 0-100 之间。 可以为 double 类型的小数。  --- # fault injection apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: review-fault-injection spec: hosts: - svc-review http: - match: route: - destination: host: svc-review fault: abort: percentage: value: 50 httpStatus: 400 案例 #  在本案例中\n srv-review 对 user 不可见 请求过程  (1) user 请求 srv-prod 时。  (2) srv-prod 根据请求参数 srv-review 获取对应的 review 信息  (3) srv-review 返回应答给 srv-prod  (4) srv-prod 组合应答信息，统一返回 user     除了上述提到的 srv-review 的错误注入。\n还在 prod 的 VirtualService 上使用了 timeout 参数， 当总请求超过 3秒 的时候， 将会出现 request timeout 错误； 如果不加此参数，会在 延迟5秒 后得到正确相应结果。\n# normal prod apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod spec: gateways: - istio-tangx-in hosts: - svc-prod - istio.tangx.in http: - match: route: - destination: host: svc-prod timeout: 3s 测试请求与结果如下。\n# 正常请求 time curl http://istio.tangx.in/prod/list {\u0026#34;data\u0026#34;:{\u0026#34;Name\u0026#34;:\u0026#34;istio in action\u0026#34;,\u0026#34;Price\u0026#34;:300,\u0026#34;Reviews\u0026#34;:{\u0026#34;1\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;,\u0026#34;commment\u0026#34;:\u0026#34;istio 功能很强大， 就是配置太麻烦\u0026#34;},\u0026#34;2\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;wangwu\u0026#34;,\u0026#34;commment\u0026#34;:\u0026#34;《istio in action》 真是一本了不起的书\u0026#34;}}},\u0026#34;version\u0026#34;:\u0026#34;v1.1.0\u0026#34;} real 0m0.011s user 0m0.004s sys 0m0.005s # 延迟5秒。 3秒请求超时 time curl http://istio.tangx.in/prod/list upstream request timeout real 0m3.014s user 0m0.004s sys 0m0.005s # 相应中止 time curl http://istio.tangx.in/prod/list {\u0026#34;error\u0026#34;:\u0026#34;Error: svc-review request abort. resp code is 400, failed\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;获取评论失败， 内部错误\u0026#34;} real\t0m0.011s user\t0m0.005s sys\t0m0.004s "},{"id":11,"href":"/istio-in-action/14-vs-http-header-operation/","title":"14 vs HTTP Header Operation","section":"","content":"VirtualService Header 操作 #  当 Envoy 在进行请求流量转发的时候， 还可以对消息 (request/response) 的 Header 进行操作。\n set : 如果不存在， 则 创建 header， 如果存在， 则 覆盖 header  spec: http: - headers: request: set: key1: value1 key2: value2 add : 如果不存在， 则 新增； 如果村子啊， 则 追加  spec: http: - headers: request: add: key1: value1 key2: value2 remove: 如果存在， 则 删除 header; 不存在, 则 忽略  spec: http: - headers: request: remove: - key1 - key2 测试用例 #  创建 vs-review 配置如下， 对 header reqeust 更新/追加/删除 进行操作。\n--- # vs review apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-review namespace: myistio # 注意 namespace spec: gateways: - istio-tangx-in hosts: - istio.tangx.in - svc-review http: # header 操作 - name: \u0026#34;header-operation\u0026#34; headers: # request header 操作与 route 在一层 request: set: # 更新 header-injection: \u0026#34;anything\u0026#34; add: # 追加 header-add-not-exist: \u0026#34;not-exist\u0026#34; header-add-exist: \u0026#34;if-overwrite\u0026#34; remove: # 删除 - header-should-remove - \u0026#34;header-should-remove2\u0026#34; 更新 review， 向 response 中添加所有 request 的 header\n// 展示 header func headerHanlder(c *gin.Context) { // response 中写入 request header \tfor key, value := range c.Request.Header { c.Header(key, fmt.Sprintf(\u0026#34;%s\u0026#34;, value)) } // 判断 header 是否注入成功 \theaderInjection := c.GetHeader(\u0026#34;header-injection\u0026#34;) if headerInjection != \u0026#34;\u0026#34; { c.Header(\u0026#34;remove-header\u0026#34;, \u0026#34;this remove-header is invisible\u0026#34;) c.JSON(http.StatusOK, gin.H{ \u0026#34;code\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;header 注入成功\u0026#34;, \u0026#34;header\u0026#34;: fmt.Sprintf(\u0026#34;header-injection value is = %s\u0026#34;, headerInjection), }) return } // 默认注入失败 \tc.JSON(http.StatusBadRequest, gin.H{ \u0026#34;code\u0026#34;: \u0026#34;failed\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;header 注入失败\u0026#34;, })s } 向 review 发送请求， 可以看到所有 header\n### header operation GET http://istio.tangx.in/header/review/header # anything, 被 envoy 覆盖 header-injection: user-request # header-exist if-overwrite, 被 envoy 追加 header-add-exist: header-exist # 不存在， 被 envoy 删除 header-should-remove: anything   "},{"id":12,"href":"/istio-in-action/16-lego-create-server-certificate/","title":"16 Lego Create Server Certificate","section":"","content":"使用 lego 创建 https 证书 #   https://go-acme.github.io/lego/dns/\n #!/bin/bash # cd $(dirname $0) source .env lego --email=\u0026#34;${EMAIL}\u0026#34; \\  --key-type rsa2048 \\  --domains=\u0026#34;${DOMAIN1}\u0026#34; \\  --path=$(pwd) --dns $DNS_PROVIDER --accept-tos run "},{"id":13,"href":"/istio-in-action/17-gw-https-support-standard/","title":"17 Gw HTTPS Support Standard","section":"","content":"Gateway 支持 https 访问 - 标准模式 #   https://istio.io/latest/docs/reference/config/networking/gateway/#ServerTLSSettings\n credentialName: The secret (of type generic) should contain the following keys and values: key: \u0026lt;privateKey\u0026gt; and cert: \u0026lt;serverCert\u0026gt;\n  创建证书 k8s secret #   在 标准模式 下， 必须使用 key 作为私钥文件名， cert 作为证书文件名。 证书文件需要 保持 与 istio-ingressgateway 服务在 相同 的命名空间。  因此证书文件的创建命令如下\nkubectl create secret generic wild-tangx-in \\  --from-file=key=./certificates/_.tangx.in.key \\  --from-file=cert=./certificates/_.tangx.in.crt \\  -n istio-system 其中\n wild-tangx-in: 是 secret name。 之后 istio gateway 需要使用 ./certificates/_.tangx.in.key(crt) 是证书私钥/文件所在的路径。  kg secret -n istio-system NAME TYPE DATA AGE wild-tangx-in Opaque 2 175m 创建支持 https 的 istio Gateway #  --- # https://istio.io/latest/docs/reference/config/networking/gateway/ apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: istio-tangx-in namespace: myistio spec: selector: istio: ingressgateway servers: - port: number: 80 name: http protocol: HTTP hosts: - istio.tangx.in tls: httpsRedirect: true # 开启 http -\u0026gt; https 301 重定向 - port: number: 443 name: https protocol: HTTPS  # 匹配协议 hosts: - \u0026#34;*.tangx.in\u0026#34; # 匹配域名， 这部分和 http 一样 tls: mode: SIMPLE  # tls 模式 credentialName: wild-tangx-in # 创建在 istio-system 下的证书 secret   .tls.httpRedirect: 是否开启 http -\u0026gt; https 的 301 重定向。 .tls.mode: tls 模式。 https 使用 SIMPLE 模式。 支持所有模式为 PASSTHROUGH / SIMPLE / MUTUAL / AUTO_PASSTHROUGH / ISTIO_MUTUAL。 .tls.credentialName: 在 k8s 环境下， 证书使用的 secret name。 不用特意挂载到 istio-ingressgateway 服务中。  测试 #  通过请求可以看到\n "},{"id":14,"href":"/istio-in-action/18-dr-simple-loadbalance/","title":"18 Dr Simple Loadbalance","section":"","content":"使用 DestionationRule 流量控制策略 - 简单负载均衡 #  简单负载均衡 策略， 官方指定名称。\n ROUND_ROBIN: 轮训策略， 默认。 LEAST_CONN: 最小连接数。 随机 选择 两个健康 后端， 通过 O(1) 算法选择连接数最少的后端。 RANDOM: 随机选择了一个 健康 后端。 如果 没有配置健康检查策略， 随机策略比轮训更好。 PASSTHROUGH: 此选项会将连接转发到调用者请求的原始 IP 地址，而不进行任何形式的负载平衡。必须谨慎使用此选项。它适用于高级用例。有关更多详细信息，请参阅 Envoy 中的原始目标负载均衡器。  --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-prod namespace: myistio spec: gateways: - istio-tangx-in hosts: - svc-prod - istio.tangx.in http: - name: \u0026#34;v1-subset\u0026#34; route: - destination: host: svc-prod --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: dr-prod spec: host: svc-prod trafficPolicy: loadBalancer: # simple: RANDOM simple: ROUND_ROBIN # simple: PASSTHROUGH # simple: LEAST_CONN 部署测试 #  ka -f istio-samples/18-dr-simple-loadbalance 10000 次请求， 2个后端， 差别不是很大\nroot@toolbox-54f88c8c95-82f4p:/tmp# ./18-dr-simple-loadbalance PASSTHROUGH v2.0.0 =\u0026gt; 5227 次 v1.0.0 =\u0026gt; 4772 次 root@toolbox-54f88c8c95-82f4p:/tmp# ./18-dr-simple-loadbalance RANDOM v2.0.0 =\u0026gt; 4943 次 v1.0.0 =\u0026gt; 5056 次 root@toolbox-54f88c8c95-82f4p:/tmp# ./18-dr-simple-loadbalance ROUND_ROBIN v2.0.0 =\u0026gt; 5019 次 v1.0.0 =\u0026gt; 4981 次 root@toolbox-54f88c8c95-82f4p:/tmp# ./18-dr-simple-loadbalance LEAST_CONN v2.0.0 =\u0026gt; 4990 次 v1.0.0 =\u0026gt; 5009 次 "},{"id":15,"href":"/istio-in-action/summary/","title":"Summary","section":"","content":"目录 #  环境准备 #    安装 docker, k3s, istio 环境  初始化第一个项目 - prod  升级项目 - prod and review  使用 lego 创建 https 证书  VirtualService #   istio VirtualService 和 k8s Ingress  创建 Gateway 允许外部访问  VirtualService 给予 uri 重写路由  使用 DestinationRule Subset 进行路由分组(版本控制)  VirtualService 基于 Header 重写路由 VirtualService 支持重写路由的所有方式  VirtualService 路由重定向  VirtualService 的重试机制  VirtualService 注入错误实现混沌测试 VirtualService 委托: 测试失败  VirtualService Header 管理 VirutalService 根据客户端 Label 转发路由(sourceLabels): 待测试  Gateway 支持 https 访问 - 标准模式  使用 DestionationRule 流量控制策略 - 简单负载均衡  "}]